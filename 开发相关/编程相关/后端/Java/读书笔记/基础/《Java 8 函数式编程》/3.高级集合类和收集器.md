# 元素顺序

直观上看，流是有序的，因为流中的元素都是按顺序处理的。这种顺序称为出现顺序。出现顺序的定义依赖于数据源和对流的操作。

1. 在一个有序集合中创建一个流时，流中的元素就按出现顺序排列。
2. 如果集合本身就是无序的，由此生成的流也是无序的。
3. 流的目的不仅是在集合类之间做转换，而且同时提供了一组处理数据的通用操作。有些集合本身是无序的，但这些操作有时会产生顺序。
4. 如使用并行流时，forEach 方法不能保证元素是按顺序处理的。

# 使用收集器

收集器，一种通用的、从流生成复杂值的结构。只要将它传给 collect 方法，所有的流就都可以使用它了。

## 转换成其他集合

你希望使用一个特定的集合收集值，而且你可以稍后指定该集合的类型。比如，你可能希望使用 TreeSet，而不是由框架在背后自动为你指定一种类型的 Set。此时就可以使用 toCollection，它接受一个函数作为参数，来创建集合。

```java
stream.collect(toCollection(TreeSet::new));
```

## 转换成值

### maxBy 和 minBy
maxBy 和 minBy 允许用户按某种特定的顺序生成一个值。定义了一个比较器，并将比较器传入 maxBy 收集器。

### averagingInt
averagingInt 方法接受一个 Lambda 表达式作参数，将流中的元素转换成一个整数，然后再计算平均数。还有和 double 和 long 类型对应的重载方法，帮助程序员将元素转换成相应类型的值。

## 数据分块

将其分解成两个集合。

有这样一个收集器 partitioningBy，它接受一个流，并将其分成两部分。它使用 Predicate 对象判断一个元素应该属于哪个部分，并根据布尔值返回一个 Map 到列表。因此，对于 true List 中的元素，Predicate 返回 true；对其他 List 中的 元素，Predicate 返回 false。

![[Pasted image 20220815170432.png]]

## 数据分组

数据分组是一种更自然的分割数据操作，与将数据分成 ture 和 false 两部分不同，可以使用任意值对数据分组。比如现在有一个由专辑组成的流，可以按专辑当中的主唱对专辑分组。

groupingBy 收集器（和 SQL 中 group by 操作类似）接受一个分类函数，用来对数据分组，就像 partitioningBy 一样，接受一个 Predicate 对象将数据分成 ture 和 false 两部分。我们使用的分类器是一个 Function 对象，和 map 操作用到的一样。

![[Pasted image 20220815171232.png]]

## 字符串

使用 Collectors.joining 收集流中的值，该方法可以方便地从一个流得到一个字符串，允许用户提供分隔符（用以分隔元素）、前缀和后缀。

## 组合收集器

## 定制收集器

## 对收集器的归一化处理

